#![doc = "Peripheral access API for CC3200 microcontrollers (generated using svd2rust v0.18.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.18.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(const_err)]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 0] = [];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Interrupt {}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        match self {}
    }
}
#[doc = "Watchdog Timer"]
pub struct WDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WDT {}
impl WDT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WDT {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WDT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WDT").finish()
    }
}
#[doc = "Watchdog Timer"]
pub mod wdt;
#[doc = "General-Purpose Input/Output Port A0"]
pub struct GPIOA0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA0 {}
impl GPIOA0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpioa0::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOA0 {
    type Target = gpioa0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOA0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOA0").finish()
    }
}
#[doc = "General-Purpose Input/Output Port A0"]
pub mod gpioa0;
#[doc = "General-Purpose Input/Output Port A1"]
pub struct GPIOA1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA1 {}
impl GPIOA1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpioa1::RegisterBlock = 0x4000_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOA1 {
    type Target = gpioa1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOA1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOA1").finish()
    }
}
#[doc = "General-Purpose Input/Output Port A1"]
pub mod gpioa1;
#[doc = "General-Purpose Input/Output Port A2"]
pub struct GPIOA2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA2 {}
impl GPIOA2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpioa2::RegisterBlock = 0x4000_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOA2 {
    type Target = gpioa2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOA2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOA2").finish()
    }
}
#[doc = "General-Purpose Input/Output Port A2"]
pub mod gpioa2;
#[doc = "General-Purpose Input/Output Port A3"]
pub struct GPIOA3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA3 {}
impl GPIOA3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpioa3::RegisterBlock = 0x4000_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa3::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOA3 {
    type Target = gpioa3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOA3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOA3").finish()
    }
}
#[doc = "General-Purpose Input/Output Port A3"]
pub mod gpioa3;
#[doc = "Application Reset-Clock Manager"]
pub struct ARCM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ARCM {}
impl ARCM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const arcm::RegisterBlock = 0x4402_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const arcm::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ARCM {
    type Target = arcm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ARCM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ARCM").finish()
    }
}
#[doc = "Application Reset-Clock Manager"]
pub mod arcm;
#[doc = "MCU Shared Configuration"]
pub struct OCP_SHARED {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for OCP_SHARED {}
impl OCP_SHARED {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ocp_shared::RegisterBlock = 0x4402_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ocp_shared::RegisterBlock {
        Self::PTR
    }
}
impl Deref for OCP_SHARED {
    type Target = ocp_shared::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for OCP_SHARED {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("OCP_SHARED").finish()
    }
}
#[doc = "MCU Shared Configuration"]
pub mod ocp_shared;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r"All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "WDT"]
    pub WDT: WDT,
    #[doc = "GPIOA0"]
    pub GPIOA0: GPIOA0,
    #[doc = "GPIOA1"]
    pub GPIOA1: GPIOA1,
    #[doc = "GPIOA2"]
    pub GPIOA2: GPIOA2,
    #[doc = "GPIOA3"]
    pub GPIOA3: GPIOA3,
    #[doc = "ARCM"]
    pub ARCM: ARCM,
    #[doc = "OCP_SHARED"]
    pub OCP_SHARED: OCP_SHARED,
}
impl Peripherals {
    #[doc = r"Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r"Unchecked version of `Peripherals::take`"]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            WDT: WDT {
                _marker: PhantomData,
            },
            GPIOA0: GPIOA0 {
                _marker: PhantomData,
            },
            GPIOA1: GPIOA1 {
                _marker: PhantomData,
            },
            GPIOA2: GPIOA2 {
                _marker: PhantomData,
            },
            GPIOA3: GPIOA3 {
                _marker: PhantomData,
            },
            ARCM: ARCM {
                _marker: PhantomData,
            },
            OCP_SHARED: OCP_SHARED {
                _marker: PhantomData,
            },
        }
    }
}
